<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Training Neural Networks</title>
    <link rel="stylesheet" type="text/css" href="public/ai/css/app.css">
</head>
<body>
    <header>
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
                <img src="public/ai/img/bu-logo.gif">
                <h1>Programming Assignment 4: Game Playing</h1>
            </div>
        </div>
        
        <div class="project-facts">
            <div class="row">
                <div class="columns small-6 medium-5 medium-offset-1 left">
                    <h3>Ivan Uvarov</h3>
                    <p>Team: Cyril Saade, David Wang, Rebecca Jellinek</p>
                </div>
                <div class="columns small-6 medium-5 left text-right">
                    <h3>CS440</h3>
                    <p>April 20, 2016</p>
                </div>
            </div>
        </div>
    </header>

    <section>
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
            
                <div class="contributions">
                    <h3>My contribution</h3>
                    <p>Worked on interface of the game (processing input and providing output) and on implementation of min max search with aplha beta pruning.</p>
                </div>

            </div>
        </div>
    </section>

    <section>
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
                <h2>Problem Definition</h2>
                <p>Our program is an artificial intelligence system that intelligently plays against the two-player game, Atropos. In order to achieve intelligence approach, we designed a static evaluator (to determine the current state of the program) and then applied the appropriate search algorithm (minMax with alpha beta pruning) to the Atropos game. We need to solve how to win the game, which is done when Player A traps Player B into completing a triangle with red, green, and yellow circles. This can be done when Player A places two circles of the same color adjacent to one another, which then forces Player B to move to a spot where she may complete a primary triangle. The motivation behind this approach is machine learning, rather than an unintelligent strategy based on either brute force or randomized plays.</p>
                <p>We assume that our player is stateless, meaning it will have no memory of its previous plays; it only knows the opponent’s last move. We will have to search the board, respective to the opponent’s last move, in order to determine the most strategic next move.</p>
            </div>
        </div>
    </section>

    <section>
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
                <h2>Program Overview</h2>
                <p>Overall algorithm description</p>
            </div>
        </div>
    </section>

    <section>
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
                <h2>Implementation Details</h2>
                <h3>Global variables (parameters)</h3>
                <p><i>MAX_DEPTH</i> - specifies maximum depth to scan in min max search</p>
                <p><i>MAX_VALUE</i> and <i>MIN_VALUE</i> - minimum and maximum values to use in AB Pruning</p>

                <h3>Helper functions</h3>
                <p><i>readCurrentState()</i> - initializes current state of the game based on the provided input string</p>
                <p><i>readLastPlayCircle()</i> - reads last played circle from the command line input</p>
                <p><i>evalEstimate()</i> - helper for eval. Provides an estimate on how good the current position is. Used when we reach the max depth and need to use an estimation.</p>
                <p><i>iteratorSize()</i> - returns number of elements in a given iterator</p>
                <p><i>permutateColors()</i> - given iterator with Atropos Circles, function returns new iterator where each of the input circles permutated with all 3 colors</p>

                <h3>Game logic functions</h3>
                <p><i>eval()</i> - evaluates current state. Checks for win/lose and assigns points correspondingly. If not a win/lose yet, call estimate helper.</p>
                <p><i>theBestMove()</i> - returns the best move you can make. Loops through all posssible moves you can make, applies minMax algorithm to each of them, and chooses the one with the largest returned value.</p>
                <p><i>minMax()</i> - searches the best move recursively using min max algorithm with alpha beta pruning</p>
            </div>
        </div>
    </section>

    <section>
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
                <h2>Running and Interface</h2>
                <h3>To compile:</h3>
                <p><i>javac uvarovisPlayer.java</i></p>
                <h3>To run:</h3>
                <p><i>java uvarovisPlayer "[13][302][1003][31002][100003][3000002][121212]LastPlay:(1,3,1,3)"</i></p>
                <h3>Input</h3>
                <p>Program takes one command line argument that represents the current state of the board and the last move.</p>
                <p>Last play can have a value "null" if you want the programm to make the first move in the game.</p>
                <h3>Output</h3>
                <p>Returns AtroposCircle for the next best move. For example, <i>(2,2,2,3)</i>.</p>
            </div>
        </div>
    </section>

    <section>
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
                <h2>Tests</h2>
                <h3>Test #1: Making the first move</h3>
                <p><b>Input:</b> <i>java uvarovisPlayer "[13][302][1003][30002][100003][3000002][121212]LastPlay:null"</i></p>
                <p><b>Expected result:</b> Anywhere</p>
                <p><b>Actual result:</b> <i>(1,1,1,5)</i></p>
                
                <h3>Test #2: Making regular move</h3>
                <p><b>Input:</b> <i>java uvarovisPlayer "[13][302][1003][31002][100003][3000002][121212]LastPlay:(1,3,1,3)"</i></p>
                <p><b>Expected result:</b> Something next to (1,3,1,3)</p>
                <p><b>Actual result:</b> <i>(2,2,2,3)</i></p>
                
                <h3>Test #3: Forcing opponent to lose</h3>
                <p><b>Input:</b> <i>java uvarovisPlayer "[32][103][3102][10223][300002][12121]LastPlay:(2,2,3,1)"</i></p>
                <p><b>Expected result:</b> <i>(2,3,2,1)</i></p>
                <p><b>Actual result:</b> <i>(2,3,2,1)</i></p>
                
                <h3>Test #4: All neighbor circles are filled, going somewhere else on the board</h3>
                <p><b>Input:</b> <i>java uvarovisPlayer "[32][113][3112][11223][300002][12121]LastPlay:(1,3,1,2)"</i></p>
                <p><b>Expected result:</b> <i>Anywhere</i></p>
                <p><b>Actual result:</b> <i>(1,1,1,4)</i></p>
            </div>
        </div>
    </section>

    <section>
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
                <h2>Results</h2>
                <p>We ran our program against provided script, and out of the 10 trials, our program won 70% of the time with a board size of 6.</p>
                <p>We also ran our program against itself with a board size of 8. And the winning rate was exactly 50% (10 out of 20 games).</p>
            </div>
        </div>
    </section>


    <section>
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
                <h2>Discussion</h2>
                <p>Our program has a success rate of 70% for board sizes of 6. On average, it takes our program 21 moves to win the game. With a success rate of 70%, our game program intelligently plays against a random player, likely due to our choice of search algorithm- MinMax. By looping through all of the possible moves, the algorithm chooses the highest value to determine our next move. Since we won more than a majority of the game, our algorithm is highly efficient in selecting the best move, though on average it is a long game of about 21 moves.</p>
            </div>
        </div>
    </section>


    <section>
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
                <h2>Conclusion</h2>
                <p>In the future, we would improve the presentation of our game interface. For example, we would include which player colored in which circle. In addition, we would provide an introduction to the game explaining which colors each number represents, so that the user can use it as a reference to help visualize the game. Limitations include randomization of 'default' player. We believe that playing against another AI gamer would show the program’s true success because it would be playing against another strategic program.</p>
                <p>Also, we would work more on our static evaluator and make it more sophisticated, so it could return better results.</p>
            </div>
        </div>
    </section>

    

    <section class="last">
        <div class="row">
            <div class="columns small-12 medium-10 small-centered">
                <h2>Credits and Bibliography</h2>
                <p>Nothing here :(</p>
            </div>
        </div>
    </section>
</body>
</html>